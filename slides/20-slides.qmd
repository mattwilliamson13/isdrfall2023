---
title: "Areal Data and Proximity"
subtitle: "HES 505 Fall 2023: Session 20"
author: "Matt Williamson"
execute: 
  eval: true
format: 
  revealjs:
    theme: mytheme.scss
    slide-number: true
    show-slide-number: print
    self-contained: true  
---

```{r}
#| include: false
library(terra)
library(tmap)
library(sf)
library(tidyverse)
```

# Objectives {background="#0033A0"}

By the end of today you should be able to:

* Describe and implement statistical approaches to interpolation

* Describe the case for identifying neighbors with areal data

* Implement contiguity-based neighborhood detection approaches

* Implement graph-based neighborhood detection approaches

# Statistical Interpolation {background="#9F281A"}

## Statistical Interpolation

::: columns
::: {.column width="40%"}
- So far, everything based on distance

- Doesn't allow for more complicated trends in the data

- May smooth over locally important phenomena
:::
:::{.column width="60%"}

```{r}
aq <- read_csv("data/ad_viz_plotval_data.csv") %>% 
  st_as_sf(., coords = c("SITE_LONGITUDE", "SITE_LATITUDE"), crs = "EPSG:4326") %>% 
  st_transform(., crs = "EPSG:8826") %>% 
  mutate(date = as_date(parse_datetime(Date, "%m/%d/%Y"))) %>% 
  filter(., date >= 2023-07-01) %>% 
  filter(., date > "2023-07-01" & date < "2023-07-31")
aq.sum <- aq %>% 
  group_by(., `Site Name`) %>% 
  summarise(., meanpm25 = mean(DAILY_AQI_VALUE))

id.cty <- tigris::counties(state="ID", progress_bar=FALSE)
tm_shape(id.cty) +
  tm_polygons(fill="gray") +
tm_shape(aq.sum) +
  tm_dots(col = "meanpm25", size=2) 
```
:::
:::

## Trend Surface Modeling

- Basically a regression on the coordinates of your data points

- Coefficients apply to the coordinates and their interaction

- Relies on different functional forms

## 0th Order Trend Surface


## Kriging
::: {style="font-size: 0.8em"}
* Previous methods predict $z$ as a (weighted) function of distance

* Treat the observations as perfect (no error)

* If we imagine that $z$ is the outcome of some spatial process such that:

$$
\begin{equation}
z(\mathbf{x}) = \mu(\mathbf{x}) + \epsilon(\mathbf{x})
\end{equation}
$$

then any observed value of $z$ is some function of the process ($\mu(\mathbf{x})$) and some error ($\epsilon(\mathbf{x})$)

* Kriging exploits autocorrelation in $\epsilon(\mathbf{x})$ to identify the trend and interpolate accordingly
:::

## Autocorrelation

* __Correlation__ the tendency for two variables to be related

* __Autocorrelation__ the tendency for observations that are closer (in space or time) to be correlated

* __Positive autocorrelation__ neighboring observations have $\epsilon$ with the same sign

* __Negative autocorrelation__ neighboring observations have $\epsilon$ with a different sign (rare in geography)

## Ordinary Kriging

* Assumes that the deterministic part of the process ($\mu(\mathbf{x})$) is an unknown constant ($\mu$)

$$
\begin{equation}
z(\mathbf{x}) = \mu + \epsilon(\mathbf{x})
\end{equation}
$$
* Specified in call to `variogram` and `gstat` as `y~1` (or some other constant)

```{r}
#| echo: true
#| eval: false

library(sp)
data(meuse)
v <- variogram(log(zinc)~1, ~x+y, data=meuse)
mv <- fit.variogram(v, vgm(1, "Sph", 300, 1))
gOK <- gstat(NULL, "log.zinc", log(zinc)~1, meuse, locations=~x+y, model=mv)
OK <- interpolate(r, gOK, debug.level=0)
```

## Ordinary Kriging

```{r}
#| eval: false

OKmsk <- mask(OK, r)
plot(OKmsk)
```

## Universal Kriging

* Assumes that the deterministic part of the process ($\mu(\mathbf{x})$) is now a function of the location $\mathbf{x}$

* Could be the location or some other attribute

* Now `y` is a function of some aspect of `x`

```{r}
#| echo: true
#| eval: false

vu <- variogram(log(zinc)~elev, ~x+y, data=meuse)
mu <- fit.variogram(vu, vgm(1, "Sph", 300, 1))
gUK <- gstat(NULL, "log.zinc", log(zinc)~elev, meuse, locations=~x+y, model=mu)
names(r) <- "elev"
UK <- interpolate(r, gUK, debug.level=0)
```

## Universal Kriging

```{r}
#| eval: false
UK.msk <- mask(UK, r)
plot(UK.msk)
```

## Universal Kriging

```{r}
#| echo: true
#| eval: false
vu <- variogram(log(zinc)~x + x^2 + y + y^2, ~x+y, data=meuse)
mu <- fit.variogram(vu, vgm(1, "Sph", 300, 1))
gUK <- gstat(NULL, "log.zinc", log(zinc)~x + x^2 + y + y^2, meuse, locations=~x+y, model=mu)
names(r) <- "elev"
UK <- interpolate(r, gUK, debug.level=0)
```

## Universal Kriging

```{r}
#| eval: false
UK.msk <- mask(UK, r)
plot(UK.msk)
```

## Co-Kriging

* relies on autocorrelation in $\epsilon_1(\mathbf{x})$ for $z_1$ AND cross correlation with other variables ($z_{2...j}$)

* Extending the ordinary kriging model gives:

$$
\begin{equation}
z_1(\mathbf{x}) = \mu_1 + \epsilon_1(\mathbf{x})\\
z_2(\mathbf{x}) = \mu_2 + \epsilon_2(\mathbf{x})
\end{equation}
$$
* Note that there is autocorrelation within both $z_1$ and $z_2$ (because of the $\epsilon$) and cross-correlation (because of the location, $\mathbf{x}$)

* Not required that all variables are measured at exactly the same points

## Co-Kriging

* Process is just a linked series of `gstat` calls

```{r}
#| echo: true
#| eval: false
gCoK <- gstat(NULL, 'log.zinc', log(zinc)~1, meuse, locations=~x+y)
gCoK <- gstat(gCoK, 'elev', elev~1, meuse, locations=~x+y)
gCoK <- gstat(gCoK, 'cadmium', cadmium~1, meuse, locations=~x+y)
coV <- variogram(gCoK)
coV.fit <- fit.lmc(coV, gCoK, vgm(model='Sph', range=1000))

coK <- interpolate(r, coV.fit, debug.level=0)

```

## Co-Kriging

```{r}
#| eval: false
plot(coV, coV.fit, main='Fitted Co-variogram')
```

## Co-Kriging

```{r}
#| eval: false
coK.msk <- mask(coK, r)
plot(coK.msk)
```

## A Note about Semivariograms


* __nugget__ - the proportion of semivariance that occurs at small distances

* __sill__ - the maximum semivariance between pairs of observations

* __range__ - the distance at which the __sill__ occurs 

* __experimental__ vs. __fitted__ variograms

## A Note about Semivariograms

![](img/slide_16/index.png)


## Fitted Semivariograms

* Rely on functional forms to model semivariance

![](img/slide_16/Variogram-models.png)

